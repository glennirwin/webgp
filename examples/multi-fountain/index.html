<!DOCTYPE html>
<html>
    <head>
        <title>WebGP - Multi Fountain - multiple vertex feedback computers with work/debug textures</title>
        <meta charset="utf-8">
    </head>
    <body style="margin: 0; background-color: black;">
        <canvas></canvas>
        <script src="../../src/webgpgpu.js"></script>
        <script>
            
            // Add Shader controls - call SHADER_CONTROLS(myUpdateFunction) in your update function
            var SHADER_STOP = false;
            var SHADER_STEP = false;
            var SHADER_SLOW = false;
            var SHADER_DEFAULT_INTERVAL = 250;
            var SHADER_SLOW_INTERVAL;
            var SHADER_LOOP_FUNCTION;  // Set when shader loop is called
            var stats;
            const SHADER_CONTROLS = (fun) => {
                if (SHADER_SLOW_INTERVAL == undefined) {
                    var butdiv = document.createElement("div");
                    butdiv.setAttribute("style", "position: absolute; top: 0; color: white;");
                    function createButton(name, code) {
                        var but = document.createElement("button");
                        but.setAttribute("onClick", code);
                        but.appendChild(document.createTextNode(name));
                        butdiv.appendChild(but);
                    }
                    createButton("Stop", "SHADER_STOP = true;");
                    createButton("Go", "SHADER_STOP = false;  SHADER_SLOW = false;  SHADER_LOOP_FUNCTION();");
                    createButton("Step", "SHADER_SLOW = false; SHADER_STOP = false; SHADER_STEP = true; SHADER_LOOP_FUNCTION();");
                    createButton("Slow", "SHADER_SLOW = true; SHADER_SLOW_INTERVAL.value = " + SHADER_DEFAULT_INTERVAL + "; SHADER_STOP = false; SHADER_LOOP_FUNCTION();");
                    SHADER_SLOW_INTERVAL = document.createElement("input");
                    SHADER_SLOW_INTERVAL.setAttribute("type", "range");
                    SHADER_SLOW_INTERVAL.setAttribute("min", 0);
                    SHADER_SLOW_INTERVAL.setAttribute("max", 2000);
                    SHADER_SLOW_INTERVAL.setAttribute("value", SHADER_DEFAULT_INTERVAL);
                    butdiv.appendChild(SHADER_SLOW_INTERVAL);
                    // add a place to show a message and adjust cycles per loop
                    stats = document.createElement("paragraph");
                    stats.appendChild(document.createTextNode(""));
                    butdiv.appendChild(stats);
                    createButton("+","cyclesPerLoop++;");
                    createButton("-","if (cyclesPerLoop > 1) cyclesPerLoop--;");
                    document.body.appendChild(butdiv);
                }
                SHADER_LOOP_FUNCTION = fun;
                if (!SHADER_STOP)
                    if (SHADER_SLOW) {
                        window.setTimeout(function () {
                            requestAnimationFrame(fun);
                        }, SHADER_SLOW_INTERVAL.value);
                    } else {
                        if (SHADER_STEP) {
                            SHADER_STOP = true;
                            SHADER_STEP = false;
                        }
                        requestAnimationFrame(fun);
                    }
            };

            // WebGPGPU Example
            const canvas = document.querySelector("canvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const WGU = WebGPGPU(canvas);

            // Structure for uniforms, values will be automatically mapped to these by name
            const uniforms = {time: Date.now(), accel: 0.5, tex: null, tex2: null};

            // Setup data textures
            let side = WGU.Util.data2d(5000);
            const texOut = WGU.Util.buildDataTexture(side, side);

            let side2 = WGU.Util.data2d(50000);
            const texOut2 = WGU.Util.buildDataTexture(side2, side2);

            // Simple computer with update and render
            // 500 big whites with high mass
            const v = new WGU.VertexFeedbackComputer({
                units: 500,
                struct: {
                    position: "vec2",
                    velocity: "vec2",
                    mass: "float",
                    color: "vec3"
                },
                uniforms: uniforms,
                initialize: (i, buffer) => buffer.set(new Uint8Array(new Float32Array([
                        Math.random(), //Position
                        Math.random(),
                        (Math.random() - .25) / 20, //Velocity
                        (Math.random() - .25) / 20,
                        1 + Math.random() * 10, //Mass
                        0xFF, //Red
                        0xFF, //Green
                        0xFF  //Blue
                    ]).buffer)),
                updateStep: {
                    glsl: `
                        void main() {
                            o_position = i_position + i_velocity;
                            o_velocity = i_velocity - 0.001 * i_position / i_mass;
                            o_mass = i_mass;
                            o_color = i_color;
                        }
                        `},
                renderStep: {
                    glsl: `
                        void main() {
                            gl_Position = vec4(i_position, 0.0, 1.0);
                            gl_PointSize = 5.0;
                            vertexColor = vec4(i_color,1.0);
                        }
                    `}
            });

            // Update and Render 50000 particles With texture out
            const v1 = new WGU.VertexFeedbackComputer({
                units: 50000,
                struct: {
                    position: "vec2",
                    velocity: "vec2",
                    mass: "float",
                    color: "vec3"
                },
                uniforms: uniforms,
                initialize: (i, buffer) => buffer.set(new Uint8Array(new Float32Array([
                        Math.random(),
                        Math.random(),
                        (Math.random() - .25) / 20,
                        (Math.random() - .25) / 20,
                        1 + Math.random() * 4,
                        Math.random(),
                        Math.random(),
                        Math.random()
                    ]).buffer)),
                textureOut: texOut2, // must assign textureColor value in glsl code

                updateStep: {
                    glsl: `
                        void main() {
                            o_position = i_position + i_velocity;
                            o_velocity = i_velocity - 0.001 * i_position / i_mass;
                            o_mass = i_mass;
                            o_color = i_color;
                            vec2 pos = vec2(float(gl_VertexID / ` + side2 + `)/` + side2 + `.0, float(gl_VertexID % ` + side2 + `)/` + side2 + `.0) * 2.0 - 1.0;
                            gl_Position = vec4(pos, 1.0,1.0);
                            textureColor = vec4(o_position,o_velocity.x * o_velocity.y, 0.5);
                        }
                    `},
                renderStep: {
                    glsl: `
                        void main() {
                            gl_Position = vec4(i_position, 0.0, 1.0);
                            vertexColor = vec4(i_color, .5);
                            gl_PointSize = i_mass/2.0;
                        }
                    `}
            });

            // Update only with texture out (red particles that get heavier over time)
            const v2 = new WGU.VertexFeedbackComputer({
                units: 5000,
                struct: {
                    position: "vec2",
                    velocity: "vec2",
                    mass: "float",
                    color: "vec3"
                },
                uniforms: uniforms,
                initialize: (i, buffer) => buffer.set(new Uint8Array(new Float32Array([
                        Math.random(),
                        Math.random(),
                        (Math.random() - .25) / 20,
                        (Math.random() - .25) / 20,
                        1 + Math.random() * 4,
                        Math.random(),
                        Math.random(),
                        Math.random()
                    ]).buffer)),
                textureOut: texOut,
                updateStep: {
                    params: {time: "float", accel: "float"},
                    glsl: `
                        void main() {
                            o_position = i_position + i_velocity;
                            o_velocity = i_velocity - 0.001 * i_position / i_mass * u_accel;
                            o_mass = i_mass + 0.0001 * u_time;
                            vec2 pos = vec2(float(gl_VertexID / ` + side + `)/` + side + `.0, float(gl_VertexID % ` + side + `)/` + side + `.0) * 2.0 - 1.0;
                            gl_Position = vec4(pos, 1.0,1.0);
                            textureColor = vec4(o_position,o_velocity.x * o_velocity.y,0.5);
                        }
                    `}
            });

            // Render only
            // Will be given the result of v2
            const r2 = new WGU.VertexFeedbackComputer({
                units: v2.units,
                struct: v2.struct.fields,
                renderStep: {
                    glsl: `
                        void main() {
                            gl_Position = vec4(i_position, 1.0, 1.0);
                            vertexColor = vec4(1,0,0,1);
                            gl_PointSize = 3.0;
                        }
                    `}
            });

            // Render a texture to a viewport (useful for debugging)
            // Will be given the texture result of v1 to display for debug
            const d1 = new WGU.VertexFeedbackComputer({
                units: v1.units,
                struct: v1.struct.fields,
                uniforms: uniforms,
                renderStep: {
                    viewport: {x: 100, y: 100, width: side2 * 3, height: side2 * 3},
                    params: {tex: "sampler2D"},
                    glsl: `
                        void main() {
                            vec2 pos = vec2(float(gl_VertexID / ` + side2 + `)/` + side2 + `.0, float(gl_VertexID % ` + side2 + `)/` + side2 + `.0) * 2.0 - 1.0;
                            vertexColor = texture(u_tex, (pos + 1.0) / 2.0);
                            gl_Position =  vec4(pos,1.0,1.0);
                            gl_PointSize = 2.0;
                        }
                    `}
            });

            // Render a second work texture
            // Will be given the texture result of v1 to display for debug
            const d2 = new WGU.VertexFeedbackComputer({
                units: v2.units,
                struct: v2.struct.fields,
                uniforms: uniforms,
                renderStep: {
                    viewport: {x: 800, y: 100, width: side * 3, height: side * 3},
                    params: {tex: "sampler2D"},
                    glsl: `
                        void main() {
                            vec2 pos = vec2(float(gl_VertexID / ` + side + `)/` + side + `.0, float(gl_VertexID % ` + side + `)/` + side + `.0) * 2.0 - 1.0;
                            vertexColor = texture(u_tex, (pos + 1.0) / 2.0);
                            gl_Position =  vec4(pos,1.0,1.0);
                            gl_PointSize = 2.0;
                        }
                    `}
            });

            uniforms.accel = 0.001;
            
            var cyclesPerLoop = 1;
            var startTime = Date.now();
            var computeTime = 0.0;
            var cycleCount = 0;
            var lastTime = Date.now();
            
            function loop() {
                WGU.Util.clear();
                for (i=0;i<cyclesPerLoop;i++) {
                    cycleCount++;
                    uniforms.time = Date.now() - lastTime; 
                    lastTime = Date.now();
                    
                    // One step of the process
                    uniforms.tex2 = texOut;
                    v.step();
                    v1.step();
                    v2.step();
                    r2.setNextBuffer(v2.getResultBuffer());
                    r2.step();
                    uniforms.tex = texOut;
                    d2.step();
                    uniforms.tex = texOut2;
                    d1.step();
                    
                    computeTime += Date.now() - lastTime;
                    if (cycleCount % 100 === 0) {
                        if (stats) stats.innerText = (cycleCount/((Date.now()-startTime)/1000)).toFixed(1)+" cycles/second "+(computeTime/cycleCount).toFixed(3)+" ms/cycle   cycles/loop="+cyclesPerLoop;
                        startTime = Date.now();
                        computeTime = 0.0;
                        cycleCount = 0;
                    }
                }
                SHADER_CONTROLS(delta => loop());
            }

            loop();   
            
        </script>
    </body>
</html>